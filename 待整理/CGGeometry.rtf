{\rtf1\ansi\ansicpg936\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red29\green133\blue25;\red110\green32\blue13;\red186\green0\blue17;
\red100\green56\blue32;\red180\green0\blue98;\red92\green38\blue153;\red0\green11\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww14000\viewh10200\viewkind0
\deftab674
\pard\tx674\pardeftab674\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \CocoaLigature0 /* CoreGraphics - CGGeometry.h\
   Copyright (c) 1998-2011 Apple Inc.\
   All rights reserved. */\cf0 \
\
\cf3 #ifndef CGGEOMETRY_H_\
#define CGGEOMETRY_H_\
\cf0 \
\cf3 #include \cf4 <CoreGraphics/CGBase.h>\cf3 \
#include \cf4 <CoreFoundation/CFDictionary.h>\cf3 \
#include \cf4 <CoreFoundation/CFBase.h>\cf3 \
#include \cf4 <CoreFoundation/CFAvailability.h>\cf3 \
#include \cf4 <stdint.h>\cf3 \
\cf0 \
\cf5 CF_IMPLICIT_BRIDGING_ENABLED\cf0 \
\
\cf5 CF_ASSUME_NONNULL_BEGIN\cf0 \
\
\cf2 /* Points. */\cf0 \
\
\cf6 struct\cf0  CGPoint \{\
    \cf7 CGFloat\cf0  x;\
    \cf7 CGFloat\cf0  y;\
\};\
\cf6 typedef\cf0  \cf6 struct\cf0  \cf7 CGPoint\cf0  CGPoint;\
\
\cf2 /* Sizes. */\cf0 \
\
\cf6 struct\cf0  CGSize \{\
    \cf7 CGFloat\cf0  width;\
    \cf7 CGFloat\cf0  height;\
\};\
\cf6 typedef\cf0  \cf6 struct\cf0  \cf7 CGSize\cf0  CGSize;\
\
\cf2 /* Vectors. */\cf0 \
\
\cf3 #define CGVECTOR_DEFINED \cf8 1\cf3 \
\cf0 \
\cf6 struct\cf0  CGVector \{\
    \cf7 CGFloat\cf0  dx;\
    \cf7 CGFloat\cf0  dy;\
\};\
\cf6 typedef\cf0  \cf6 struct\cf0  \cf7 CGVector\cf0  CGVector;\
\
\cf2 /* Rectangles. */\cf0 \
\
\cf6 struct\cf0  CGRect \{\
    \cf7 CGPoint\cf0  origin;\
    \cf7 CGSize\cf0  size;\
\};\
\cf6 typedef\cf0  \cf6 struct\cf0  \cf7 CGRect\cf0  CGRect;\
\
\cf2 /* Rectangle edges. */\cf0 \
\
\cf6 typedef\cf0  \cf6 CF_ENUM\cf0 (uint32_t, CGRectEdge) \{\
    CGRectMinXEdge, CGRectMinYEdge, CGRectMaxXEdge, CGRectMaxYEdge\
\};\
\
\cf2 /* The "zero" point -- equivalent to CGPointMake(0, 0). */\cf0  \
\
\cf5 CG_EXTERN\cf0  \cf6 const\cf0  \cf7 CGPoint\cf0  CGPointZero\
      \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* The "zero" size -- equivalent to CGSizeMake(0, 0). */\cf0  \
\
\cf5 CG_EXTERN\cf0  \cf6 const\cf0  \cf7 CGSize\cf0  CGSizeZero\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* The "zero" rectangle -- equivalent to CGRectMake(0, 0, 0, 0). */\cf0  \
\
\cf5 CG_EXTERN\cf0  \cf6 const\cf0  \cf7 CGRect\cf0  CGRectZero\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* The "empty" rect. This is the rectangle returned when, for example, we\
   intersect two disjoint rectangles. Note that the null rect is not the\
   same as the zero rect. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 const\cf0  \cf7 CGRect\cf0  CGRectNull\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* The infinite rectangle. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 const\cf0  \cf7 CGRect\cf0  CGRectInfinite\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_4, __IPHONE_2_0);\
\
\cf2 /* Make a point from `(x, y)'. */\cf0 \
\
\cf5 CG_INLINE\cf0  \cf7 CGPoint\cf0  CGPointMake(\cf7 CGFloat\cf0  x, \cf7 CGFloat\cf0  y);\
\
\cf2 /* Make a size from `(width, height)'. */\cf0 \
\
\cf5 CG_INLINE\cf0  \cf7 CGSize\cf0  CGSizeMake(\cf7 CGFloat\cf0  width, \cf7 CGFloat\cf0  height);\
\
\cf2 /* Make a vector from `(dx, dy)'. */\cf0 \
\
\cf5 CG_INLINE\cf0  \cf7 CGVector\cf0  CGVectorMake(\cf7 CGFloat\cf0  dx, \cf7 CGFloat\cf0  dy);\
\
\cf2 /* Make a rect from `(x, y; width, height)'. */\cf0 \
\
\cf5 CG_INLINE\cf0  \cf7 CGRect\cf0  CGRectMake(\cf7 CGFloat\cf0  x, \cf7 CGFloat\cf0  y, \cf7 CGFloat\cf0  width,\
  \cf7 CGFloat\cf0  height);\
\
\cf2 /* Return the leftmost x-value of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetMinX(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the midpoint x-value of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetMidX(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the rightmost x-value of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetMaxX(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the bottommost y-value of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetMinY(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the midpoint y-value of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetMidY(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the topmost y-value of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetMaxY(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the width of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetWidth(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the height of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGFloat\cf0  CGRectGetHeight(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `point1' and `point2' are the same, false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGPointEqualToPoint(\cf7 CGPoint\cf0  point1, \cf7 CGPoint\cf0  point2)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `size1' and `size2' are the same, false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGSizeEqualToSize(\cf7 CGSize\cf0  size1, \cf7 CGSize\cf0  size2)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `rect1' and `rect2' are the same, false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectEqualToRect(\cf7 CGRect\cf0  rect1, \cf7 CGRect\cf0  rect2)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Standardize `rect' -- i.e., convert it to an equivalent rect which has\
   positive width and height. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGRect\cf0  CGRectStandardize(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `rect' is empty (that is, if it has zero width or height),\
   false otherwise. A null rect is defined to be empty. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectIsEmpty(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `rect' is the null rectangle, false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectIsNull(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `rect' is the infinite rectangle, false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectIsInfinite(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_4, __IPHONE_2_0);\
\
\cf2 /* Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and\
   decrease its size by `(2*dx, 2*dy)'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGRect\cf0  CGRectInset(\cf7 CGRect\cf0  rect, \cf7 CGFloat\cf0  dx, \cf7 CGFloat\cf0  dy)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Expand `rect' to the smallest rect containing it with integral origin and\
   size. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGRect\cf0  CGRectIntegral(\cf7 CGRect\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the union of `r1' and `r2'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGRect\cf0  CGRectUnion(\cf7 CGRect\cf0  r1, \cf7 CGRect\cf0  r2)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return the intersection of `r1' and `r2'. This may return a null rect. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGRect\cf0  CGRectIntersection(\cf7 CGRect\cf0  r1, \cf7 CGRect\cf0  r2)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Offset `rect' by `(dx, dy)'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CGRect\cf0  CGRectOffset(\cf7 CGRect\cf0  rect, \cf7 CGFloat\cf0  dx, \cf7 CGFloat\cf0  dy)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Make two new rectangles, `slice' and `remainder', by dividing `rect' with\
   a line that's parallel to one of its sides, specified by `edge' -- either\
   `CGRectMinXEdge', `CGRectMinYEdge', `CGRectMaxXEdge', or\
   `CGRectMaxYEdge'. The size of `slice' is determined by `amount', which\
   measures the distance from the specified edge. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 void\cf0  CGRectDivide(\cf7 CGRect\cf0  rect, \cf7 CGRect\cf0  *  slice,\
    \cf7 CGRect\cf0  *  remainder, \cf7 CGFloat\cf0  amount, \cf7 CGRectEdge\cf0  edge)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `point' is contained in `rect', false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectContainsPoint(\cf7 CGRect\cf0  rect, \cf7 CGPoint\cf0  point)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `rect2' is contained in `rect1', false otherwise. `rect2'\
   is contained in `rect1' if the union of `rect1' and `rect2' is equal to\
   `rect1'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectContainsRect(\cf7 CGRect\cf0  rect1, \cf7 CGRect\cf0  rect2)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /* Return true if `rect1' intersects `rect2', false otherwise. `rect1'\
   intersects `rect2' if the intersection of `rect1' and `rect2' is not the\
   null rect. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectIntersectsRect(\cf7 CGRect\cf0  rect1, \cf7 CGRect\cf0  rect2)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_0, __IPHONE_2_0);\
\
\cf2 /*** Persistent representations. ***/\cf0 \
\
\cf2 /* Return a dictionary representation of `point'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CFDictionaryRef\cf0   CGPointCreateDictionaryRepresentation(\
    \cf7 CGPoint\cf0  point)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_5, __IPHONE_2_0);\
\
\cf2 /* Make a CGPoint from the contents of `dict' (presumably returned earlier\
   from `CGPointCreateDictionaryRepresentation') and store the value in\
   `point'. Returns true on success; false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGPointMakeWithDictionaryRepresentation(\
    \cf7 CFDictionaryRef\cf0  \cf6 __nullable\cf0  dict, \cf7 CGPoint\cf0  * \cf6 __nullable\cf0  point)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_5, __IPHONE_2_0);\
\
\cf2 /* Return a dictionary representation of `size'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CFDictionaryRef\cf0   CGSizeCreateDictionaryRepresentation(\cf7 CGSize\cf0  size)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_5, __IPHONE_2_0);\
\
\cf2 /* Make a CGSize from the contents of `dict' (presumably returned earlier\
   from `CGSizeCreateDictionaryRepresentation') and store the value in\
   `size'. Returns true on success; false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGSizeMakeWithDictionaryRepresentation(\
    \cf7 CFDictionaryRef\cf0  \cf6 __nullable\cf0  dict, \cf7 CGSize\cf0  * \cf6 __nullable\cf0  size)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_5, __IPHONE_2_0);\
\
\cf2 /* Return a dictionary representation of `rect'. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf7 CFDictionaryRef\cf0   CGRectCreateDictionaryRepresentation(\cf7 CGRect\cf0 )\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_5, __IPHONE_2_0);\
\
\cf2 /* Make a CGRect from the contents of `dict' (presumably returned earlier\
   from `CGRectCreateDictionaryRepresentation') and store the value in\
   `rect'. Returns true on success; false otherwise. */\cf0 \
\
\cf5 CG_EXTERN\cf0  \cf6 bool\cf0  CGRectMakeWithDictionaryRepresentation(\
    \cf7 CFDictionaryRef\cf0  \cf6 __nullable\cf0  dict, \cf7 CGRect\cf0  * \cf6 __nullable\cf0  rect)\
    \cf5 CG_AVAILABLE_STARTING\cf0 (__MAC_10_5, __IPHONE_2_0);\
\
\cf2 /*** Definitions of inline functions. ***/\cf0 \
\
\cf5 CG_INLINE\cf0  \cf7 CGPoint\cf0 \
CGPointMake(\cf7 CGFloat\cf0  x, \cf7 CGFloat\cf0  y)\
\{\
  \cf7 CGPoint\cf0  p; p.\cf7 x\cf0  = x; p.\cf7 y\cf0  = y; \cf6 return\cf0  p;\
\}\
\
\cf5 CG_INLINE\cf0  \cf7 CGSize\cf0 \
CGSizeMake(\cf7 CGFloat\cf0  width, \cf7 CGFloat\cf0  height)\
\{\
  \cf7 CGSize\cf0  size; size.\cf7 width\cf0  = width; size.\cf7 height\cf0  = height; \cf6 return\cf0  size;\
\}\
\
\cf5 CG_INLINE\cf0  \cf7 CGVector\cf0 \
CGVectorMake(\cf7 CGFloat\cf0  dx, \cf7 CGFloat\cf0  dy)\
\{\
  \cf7 CGVector\cf0  vector; vector.\cf7 dx\cf0  = dx; vector.\cf7 dy\cf0  = dy; \cf6 return\cf0  vector;\
\}\
\
\cf5 CG_INLINE\cf0  \cf7 CGRect\cf0 \
CGRectMake(\cf7 CGFloat\cf0  x, \cf7 CGFloat\cf0  y, \cf7 CGFloat\cf0  width, \cf7 CGFloat\cf0  height)\
\{\
  \cf7 CGRect\cf0  rect;\
  rect.\cf7 origin\cf0 .\cf7 x\cf0  = x; rect.\cf7 origin\cf0 .\cf7 y\cf0  = y;\
  rect.\cf7 size\cf0 .\cf7 width\cf0  = width; rect.\cf7 size\cf0 .\cf7 height\cf0  = height;\
  \cf6 return\cf0  rect;\
\}\
\
\cf5 CG_INLINE\cf0  \cf6 bool\cf0 \
__CGPointEqualToPoint(\cf7 CGPoint\cf0  point1, \cf7 CGPoint\cf0  point2)\
\{\
  \cf6 return\cf0  point1.\cf7 x\cf0  == point2.\cf7 x\cf0  && point1.\cf7 y\cf0  == point2.\cf7 y\cf0 ;\
\}\
\cf3 #define CGPointEqualToPoint __CGPointEqualToPoint\
\cf0 \
\cf5 CG_INLINE\cf0  \cf6 bool\cf0 \
__CGSizeEqualToSize(\cf7 CGSize\cf0  size1, \cf7 CGSize\cf0  size2)\
\{\
  \cf6 return\cf0  size1.\cf7 width\cf0  == size2.\cf7 width\cf0  && size1.\cf7 height\cf0  == size2.\cf7 height\cf0 ;\
\}\
\
\cf3 #define CGSizeEqualToSize __CGSizeEqualToSize\
\cf0 \
\cf5 CF_ASSUME_NONNULL_END\cf0 \
\
\cf5 CF_IMPLICIT_BRIDGING_DISABLED\cf0 \
\
\cf3 #endif \cf2 /* CGGEOMETRY_H_ */\cf3 \
}